;;;;;;;;;;;;;;;;;;;;;;;;;
CONADR:	EQU	07600H	; Адрес символа под курсором в памяти;
CONPOS:	EQU	07602H	; Координаты позиции X,Y курсора на экране;
CON@PX:	EQU	07602H	; Консольная позиция курсора по X;
CON@PY:	EQU	07603H	; Консольная позиция курсора по Y;
CONSTA:	EQU	07604H	; Консольный статус в Escape-последовательности;
CONBEL:	EQU	07607H	; Длительность и высота тона "звонка"
CONLEN:	EQU	0760FH	; Ширина одного знакоряда в настройках ИМС ВГ75 (стандарт: 78);
CONORG:	EQU	07610H	; Консольный организатор окна с позицией XO,YO относительно начала буфера;
CON@XO:	EQU	07610H	; Консольная абсолютная позиция окна по горизонтали (стандарт: 8);
CON@YO:	EQU	07611H	; Консольная абсолютная позиция окна по вертикали (стандарт: 3);
CONBOX:	EQU	07612H	; Относительный размер бокса ограничителя окна на экране (стандарт: 63x24);
CON@XS:	EQU	07612H	; Относительный размер окна по горизонтали с указанием крайнего правого столбца (стандарт: 63);
CON@YS:	EQU	07613H	; Относительный размер окна по вертикали с указанием крайней нижней строки (стандарт: 24);
;;;;;;;;;;;;;;;;;;;;;;;;;
GETKEY:	EQU	0F803H	; Чтение кода нажатой клавиши с ожиданием.
GETRAP:	EQU	0FAB0H	; Адрес вызова "пользовательской ловушки".
V78X30:	EQU	0FACEH	; Восстановление стандартного режима консоли.
;;;;;;;;;;;;;;;;;;;;;;;;;

	MVI	A,00CH	; Установление значений окна по умолчанию.
LOOP:	CALL	PUT@A	; Обработка и вывод символа на экран.
	CALL	GETKEY	; Ждём реакции пользователя.
	JMP	LOOP	; Замыкаем цикл печати.
	;;;;;;;;;;;;;;;;;

	;;;;;;;;;;;;;;;;;
PUTHEX:	CALL	PUTNBL	; Печатаем старшую тетраду.
PUTNBL:	RRC		; Проворачиваем
	RRC		; аккумулятор
	RRC		; на четыре бита
	RRC		; (двойная прокрутка восстановит значение).
	PUSH	PSW	; Запоминаем в стеке.
	ANI	00FH	; Маскируем биты соседней тетрады
	CPI	00AH	; и проверяем на десятичный диапазон.
	SBI	02FH	; Корректируем на единицу, вписываясь в ASCII.
	DAA		; Формируем полноценный символ тетрады.
	DB	0FEH	; Трюковой код для пропуска одной инструкции.
	;;;;;;;;;;;;;;;;;
PUT@A:	PUSH	PSW	; FCB8
	CMP	A	; Трюковая операция для гарантированного
	DB	0C2H	; срабатывания пропуска следующих двух инструкций.
	;;;;;;;;;;;;;;;;;
PUT@C:	PUSH	PSW	; Сохраняем аккумулятор
	MOV	A,C	; Читаем регистр C
	PUSH	H	; Запоминаем в стеке HL.
	PUSH	D	; Запоминаем в стеке DE.
	PUSH	B	; Запоминаем в стеке BC.
	ANI	07FH	; Маскируем под КОИ-7
	CPI	00CH	; Код "Домой" имеет
	JZ	PUT@0C	; наивысший приоритет.
	CPI	01FH	; Код "Чистка" имеет
	JZ	PUT@1F	; наивысший приоритет.
	LXI	H,PUT@ZZ; Точка завершения подпрограммы
	PUSH	H	; помещается в стек.
	LHLD	CONORG	; Загружаем позицию "организации" окна
	XCHG		; в регистровую пару DE.
	LHLD	CONBOX	; Загружаем размер ограничивающего "бокса"
	DAD	D	; и вычисляем крайние позиции курсора в окне.
	MOV	C,L	; Сохраняем их в
	MOV	B,H	; регистровой паре BC.
	LHLD	CONPOS	; Загружаем позицию курсора
	XCHG		; и помещаем в регистровую пару DE.
	JMP	PUT@S0	; Переходим к основной части обработки.
	;;;;;;;;;;;;;;;;;
	; CODE 1F
	;;;;;;;;;;;;;;;;;
PUT@1F:	LXI	H,076D0H; Начало стандартного буфера экрана
PUT@AF:	XRA	A	; Очищаем аккумулятор
	MOV	M,A	; для очищения ячейки экрана.
	INX	H	; Переходим к следующей ячейке
	ORA	H	; и проверяем, не покинули ли ОЗУ?
	JP	PUT@AF	; Если пока ещё нет, продолжаем очищать.
	;;;;;;;;;;;;;;;;;
	; CODE 0C
	;;;;;;;;;;;;;;;;;
PUT@0C:	CALL	V78X30	; Вызываем подпрограмму установки стандартного режима.
	LXI	H,005F0H; Константа для "звонка"
	SHLD	CONBEL	; записывается в служебные ячейки.
	LXI	H,CONLEN; В ячейку параметра длины строки
	MVI	M,04EH	; записываем стандартный код 78.
	LXI	H,00308H; Начальная позиция +8+3
	SHLD	CONORG	; записывается в организатор окна
	XCHG		; и запоминается в DE.
	LXI	H,0183FH; Стандартная граница 63x24
	SHLD	CONBOX	; записывается в ограничивающий бокс окна.
	LXI	H,077C2H; Стандартный экранный адрес левого верхнего угла.
	XRA	A	; Очищаем все биты статуса.
	;;;;;;;;;;;;;;;;;
PUT@ZZ:	STA	CONSTA	; Записываем в байт Esc-статуса.
	SHLD	CONADR	; Сохраняем экранный адрес курсора.
	LXI	H,0C001H; Подготавливаем ВГ75 на
	MVI	M,080H	; установку позиции курсора.
	DCX	H	; Позицию передаём в последовательности
	MOV	M,E	; "столбец" и
	MOV	M,D	; "строка".
	XCHG		; Теперь позицию из DE
	SHLD	CONPOS	; сохраняем в служебных ячейках.
	POP	B	; Извлекаем регистры BC,
	POP	D	; DE и
	POP	H	; HL.
	CALL	0FE01H	; Именно здесь обращаемся к опросу клавиатуры, экономя стек.
	POP	PSW	; Восстанавливаем Аккумулятор.
	RET		;
	;;;;;;;;;;;;;;;;;
PUT@07:	PUSH	H	; Запоминаем указатель,
	LHLD	CONBEL	; загружаем в него параметры "звонка".
	XTHL		; Через верхушку стека
	POP	B	; переносим параметры в BC.
	;;;;;;;;;;;;;;;;;
BEEP:	MOV	A,B
BEEP@1:	EI
	DCR	A
	JNZ	BEEP@1
	MOV	A,B
BEEP@2:	DI
	DCR	A
	JNZ	BEEP@2
	DCR	C
	JNZ	BEEP
	RET

	;;;;;;;;;;;;;;;;;
	; 16 BYTES + 12 BYTES = 28 BYTES
	;;;;;;;;;;;;;;;;;
PUT@S0:	LHLD	CONSTA-1; Считываем код Escape-статуса
	DCR	H	; и подготавливаем флаги SF ZF PF.
	LHLD	CONADR	; Читаем указатель на ячейку под курсором.
	JZ	PUT@S1	; Если Escape-статус был в 01 - обрабатываем команду.
	JPO	PUT@S2	; Если Escape-статус был в 02 - выбираем строку.
	JP	PUT@S3	; Если Escape-статус был в 00 - просто печатаем текст.
	;;;;;;;;;;;;;;;;;
	; Основная процедура управления курсором или печати.
	;;;;;;;;;;;;;;;;;
PUT@CC:	SUI	01AH	; Математический трюк для общего сокращения кода.
	CPI	001H	; Если код 1B (АР2/ESC),
	RZ		; возвращаемся к команде сохранения Escape-статуса.
	XTHL		; Иначе, корректируем адрес возврата,
	DCX	H	; чтобы обнулить Escape-статус
	XTHL		; перед выходом из подпрограммы.
	ORA	A	; Если код 1A,
	JZ	PUT@1A	; двигаем курсор вниз.
	INR	A	; Если код 19,
	JZ	PUT@19	; двигаем курсор вверх.
	INR	A	; Если код 18,
	JZ	PUT@18	; двигаем курсор вправо.
	ADI	010H	; Математическим трюком прыгаем к коду 08.
	JZ	PUT@08	; Если код 08, двигаем курсор влево.
	INR	A	; Если код 07,
	JZ	PUT@07	; генерируем короткий звонкий звуковой сигнал.
	ADI	007H	; Аннулируем всякие трюки.
	CPI	00AH	; Если код 0A,
	JZ	PUT@0A	; переходим на новую (чистую) строку.
	CPI	00DH	; Если код 0D,
	JZ	PUT@0D	; переходим к началу строки (в активной области).
	;;;;;;;;;;;;;;;;;
	MOV	M,A	; Иначе - просто выводим символ на экран.
	INX	H	; Смещаемся к следующему знакоместу.
	MOV	A,E	; Проверяем позицию по столбцам.
	INR	E	; Переходим к следующему столбцу.
	CMP	C	; Если столбец не самый крайний,
	RC		; просто возвращаемся.
	;;;;;;;;;;;;;;;;;
	CALL	PUT@0D	; Иначе - переходим к началу строки.
	;;;;;;;;;;;;;;;;;
	; CODE 0A
	;;;;;;;;;;;;;;;;;
PUT@0A:	MOV	A,B	; В зависимости от высоты активной области,
	DCR	A	; проверяем, не вышел ли курсор
	CMP	D	; за границы нижней строки?
	JNC	SET@UD	; Если нет, делаем шаг вниз в позиции и адресации.
	;;;;;;;;;;;;;;;;;
PUT@@A:	SBB	A	; Выставляем код 00 или FF в зависимости от
	MOV	B,A	; направления прокрутки (вниз/вверх) в регистре B.
	LDA	CONORG+1; Читаем позицию окна по вертикали.
	CMA		; Выполняем составную инструкцию NEG
	INR	A	; из нескольких операций,
	ADD	D	; чтобы вычесть нижнюю позицию из верхней.
	PUSH	D	; Сохраняем служебные регистры DE и HL,
	PUSH	H	; так как дальше - довольно сложный цикл.
	MOV	D,A	; Регистр D будет счётчиком строк в области окна.
	CALL	PUT@0D	; Находим самый первый столбец в области окна.
	MOV	A,C	; Из кррайней позиции столбца оконной области
	SUB	E	; вычитаем позицию начала и узнаём ширину окна.
	MOV	E,A	; Сохраняем ширину прокрутки в регистр E.
	LDA	CONLEN	; Читаем ширину знакоряда в экранном буфере,
	XRA	B	; дополняем опционально составной инструкцией NEG,
	SBB	B	; в зависимости от направления вертикальной прокрутки
	MOV	C,A	; и формируем верное значение в регистровой паре BC.
	;;;;;;;;;;;;;;;;;
	; NEXT COLUMN
	;;;;;;;;;;;;;;;;;
PUT@NC:	PUSH	D	; Запоминаем счётчик столбцов E
	PUSH	H	; вместе с адресом крайнего символа в столбце.
	MVI	E,000H	; Первый записываем символ в столбец - "пусто".
	;;;;;;;;;;;;;;;;;
	; ROWS SCROLLING
	;;;;;;;;;;;;;;;;;
PUT@RS:	MOV	A,E	; Сохраняем записываем (предыдущий) символ.
	MOV	E,M	; Замещаем его кодом из текущей экранной позиции.
	MOV	M,A	; На экране ставим символ из знакоместа ниже/выше.
	DAD	B	; Перемещаемся на одну позицию вверх/вниз.
	SBB	A	; Очередными трюками
	ADD	A	; с составной инструкцией
	STC		; NEG добиваемся
	ADC	D	; одного шага вверх/вниз
	MOV	D,A	; в счётчике знакорядов D.
	LDA	CONBOX+1; Читаем позицию окна по вертикали.
	CMP	D	; Проверяем, не покинули ли знакоряды оконной области?
	JNC	PUT@RS	; Если нет - продолжаем смещение всех символов.
	POP	H	; Восстанавливаем адрес
	POP	D	; и позицию прокрутки.
	INX	H	; Переходим к следующему столбцу,
	DCR	E	; уменьшая счётчик столбцов на единицу.
	JP	PUT@NC	; Продолжаем, пока все столбцы окна не прокрутились.
	POP	H	; Восстанавливаем адрес знакоместа
	POP	D	; и позицию каретки.
	RET		;
	;;;;;;;;;;;;;;;;;
	; CODE 08 - 7 BYTES + 7 BYTES + 7 BYTES + 17 = 38 BYTES
	;;;;;;;;;;;;;;;;;
PUT@08:	LDA	CONORG	; Читаем позицию окна по горизонтали
	CMP	E	; и сверяемся с позицией курсора.
	DCX	H	; Смещаемся левее по знакоместам
	DCR	E	; и позицией каретки.
	RC		; Возвращаемся, если ничего не перескочили.
	;;;;;;;;;;;;;;;;;
	; LAST COLUMN - 17 BYTES
	;;;;;;;;;;;;;;;;;
PUT@LC:	MOV	A,C	; Для поиска крайнего столбца.
PUT@LD:	INX	H	; Двигаемся к адресу следующего знакоместа,
	INR	E	; смещая позицию каретки на шаг вправо.
	CMP	E	; Сверяемся с позиций крайнего столбца.
	JNZ	PUT@LD	; Продолжаем, пока не достигли правого края.
	;;;;;;;;;;;;;;;;;
	; CODE 19 - 7 BYTES
	;;;;;;;;;;;;;;;;;
PUT@19:	LDA	CONORG+1; Читаем позицию окна по вертикали,
	CMP	D	; сверяясь с текущей позицией каретки.
	JNC	PUT@@A	; Вышли за границу? Вызываем обратную прокрутку вниз.
	;;;;;;;;;;;;;;;;;
	; GO TO UP/DOWN - 17 BYTES
	;;;;;;;;;;;;;;;;;
SET@UD:	PUSH	B	; Сохраняем BC.
	SBB	A	; Выставляем биты в соответствии со входным флагом CF.
	MOV	B,A	; Запоминаем в B код 00 (CF=0) или FF (CF=1).
	LDA	CONLEN	; Читаем длину одной экранной строки в байтах ПДП.
	XRA	B	; Опционально выполняем составную инструкцию NEG,
	SUB	B	; но только если входной флаг CF был установлен.
	MOV	C,A	; Запоминаем длину (возможно - отрицательную) в C.
	DAD	B	; Один шаг вниз/вверх в адресации позиции символа.
	SBB	A	; Соответственно, получив 00 или FF,
	STC		; следует дополнить до единицы
	ADC	A	; и удвоить, чтобы достичь эффекта инструкции NEG.
	ADD	D	; Теперь один шаг вниз/вверх делаем в координате Y
	MOV	D,A	; и сохраняем её в регистре D.
	POP	B	; Восстанавливаем BC.
	RET		; Всего: 17 байтов / 98 тактов.
	;;;;;;;;;;;;;;;;;
	; CODE 18 - 27 BYTES
	;;;;;;;;;;;;;;;;;
PUT@18:	INX	H	; Перемещаемся к следующему экранному знакоместу
	MOV	A,E	; и проверяем позицию.
	INR	E	; Смещаем позицию каретки вправо.
	CMP	C	; Если не было пересечения крайнего правого столбца,
	RC		; просто возвращаемся.
	CALL	PUT@0D	; Иначе - возвращаемся к начальному столбцу.
	;;;;;;;;;;;;;;;;;
	; CODE 1A - 19 BYTES
	;;;;;;;;;;;;;;;;;
PUT@1A:	CALL	SET@UD	; Делаем шаг вниз
	DCR	A	; и проверяем позицию
	CMP	B	; на предмет пересечения нижней крайней строки.
	RC		; Возвращаемся, если всё в границах.
	;;;;;;;;;;;;;;;;;
	; TOP LINE - 13 BYTES
	;;;;;;;;;;;;;;;;;
PUT@OP:	LDA	CONORG+1; Загружаем позицию окна по вертикали
	CMP	D	; и сверяемся с текущей позицией курсора.
	MVI	A,002H	; Escape-код установки позиции курсора по вертикали
	RNC		; возвращаем, если нашли верхнюю строку.
	CALL	SET@UD	; Иначе - делаем шаг вверх и продолжаем поиск.
	JMP	PUT@OP	; 
	;;;;;;;;;;;;;;;;;
	; CODE 0D - 10 BYTES
	;;;;;;;;;;;;;;;;;
PUT@0D:	LDA	CONORG	; Читаем позицию начального столбца оконной области.
PUT@OD:	CMP	E	; Сверяемся с позицией каретки.
	RZ		; Ничего не делаем, если каретка и так в начале.
	DCR	E	; Иначе - смещаем её левее
	DCX	H	; и перемещаемся к предыдущему знакоместу.
	JMP	PUT@OD	; 10 BYTES
	;;;;;;;;;;;;;;;;;
	; Escape+??? - 17 BYTES
	;;;;;;;;;;;;;;;;;
PUT@S1:	PUSH	PSW	; Для начала
	XRA	A	; - очистим
	STA	CONSTA	; Escape-статус.
	POP	PSW	; Перед тем,
	CPI	059H	; как проверить на команду позиционирования курсора.
	JNZ	GETRAP	; Если что-то иное - передадим "ловушке пользователя".
	CALL	PUT@0D	; Иначе - переходим к начальному столбцу окна.
	JMP	PUT@OP	; Иначе - ищем самую верхнюю строку оконной области.
	;;;;;;;;;;;;;;;;;
	; ESC+Y(ROW) - 14 BYTES
	;;;;;;;;;;;;;;;;;
PUT@S2:	SUI	01CH	; Делаем поправку.
PUT@L2:	CPI	004H	; Возвращаемся с кодом Escape-статуса 04,
	RZ		; если строка установилась.
	PUSH	PSW	; Иначе, сохраняем счётчик
	CNC	PUT@1A	; перед шагом вниз.
	POP	PSW	; Восстанавливаем счётчик
	DCR	A	; и продолжаем искать нужную строку.
	JMP	PUT@L2	; 14 BYTES
	;;;;;;;;;;;;;;;;;
	; ESC+Y(COLUMN)	- 12 BYTES
	;;;;;;;;;;;;;;;;;
PUT@S3:	SUI	01FH	; Делаем поправку.
PUT@L3:	DCR	A	; Считаем количество оставшихся позиций вправо.
	RZ		; Возвращаемся, если позиция установилась.
	PUSH	PSW	; Иначе, сохраняем счётчик
	CALL	PUT@18	; и делаем шаг вправо.
	POP	PSW	; Восстанавливаем счётчик и продолжаем.
	JMP	PUT@L3	; 12 BYTES
